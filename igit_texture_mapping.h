#ifndef IGIT_TEXTURE_MAPPING_H
#define IGIT_TEXTURE_MAPPING_H

#include "data_type.h"
#include"opencv2/opencv.hpp"
#include"igit_MRF.h"

#include <QObject>
#include <QTextEdit>
#include<QImage>

typedef PointXYZRGBNormal Point;

class TextureMapping : public QObject
{
	Q_OBJECT

public:

	enum FacetRelationShip {COMMON_VERTEX, COMMON_EDGE, NONE};

	TextureMapping(){
		t_height_ = 0;
		t_width_ = 0;
	}
    
	// initialization for processing texture images
	void initialization();

	// load gray images for projection and MRF Optimization
	bool loadGrayImages();

	// load images used for creating teture images
	bool loadTextureImages();

	// load projection matrix
	bool loadCameras();

	// load visibility information
	bool loadVisibility();

	// compute visibility of each vertx
	void computeVertexNormalAndVisibility();

	// visibilities of the vertices, needed to be computed for the 
	bool computeFacetsVisibilityFromFile();

	// as a supplement for the method "computeFacetsVisibilityFromFile"
	void computeFacetsVisibilityViaProjection();

	// compute the texture coordinates of each facet in each visible view
	void computeTextureCoordinates();

	// bool filter visibility
	void filterVisibility();

	// check whether the view is valid or not
	bool isValidVis(QPoint pt, float thresh);

	// facet trimmer
	void facetTrimmer();

	//update facets edges and textures, this function  same to the function in igit_poisson.cpp
	void updateMesh(QVector<QVector<Point> > & facets);

	// compute the visibility as well as the texture coordinates 
	void computeFacetsVisibilityAndCoordinates();

	// relationship between two facets
	FacetRelationShip facetRelation(int i, int j);

	// calculate the K nearest neighbours of the facets. Two kinds of neighbours are considering
	// the first facets sharing an edge are considered as neighboursand second facets sharing a 
	// vertex are treated as neighbours 
	QVector<QVector<int> > kNearestNeighboursFacets(TextureMapping::FacetRelationShip type);

	// get final facet vis
	void MRF_Optimization();

	// after MRF optimization, each facet has a visible view, and we collect all the visible views
	// and only load the image actually used in the creating texture image process.
	void collectUsefulVis();

	// transfrom from base plane to texure image
	cv::Mat getTransfromMat();

	// create texture image
	void createTextureImage(int imgSize);

	// poisson image Editing
	void poissonImageEditing();
	void prepareForEditing();
	void imageEditing();

	// check a point is contains in which facet, the facets are all projected onto a 2D plane
	int inWhichFacet(const QPointF &pt, const QVector<int>&facets, const QVector<QPolygonF> &polygons);

	void setPointsIdsPtr(QSet<int> *ptr)
	{
		t_points_ids_ = ptr;
	}
	void setDensePointsPtr(QVector<Point>* ptr){
		t_dense_pts_ = ptr;
	}
	void setMeshVeticesPtr(QVector<Point>* ptr){ t_vertices_ = ptr; }
	void setMeshFacetPtr(QVector<QVector<int> > * ptr){ t_facets_ = ptr; }
	void setMeshEdgesPtr(QVector<QPair<int, int> >* ptr){ t_edges_ = ptr; }
	//void setImagesPtr(QMap<QString, QImage> * ptr){ t_images_ = ptr; }
	void setCamerasPtr(QMap< QString, Camera> *ptr){ t_cameras_ = ptr;}
	void setTextureCoordatesPtr( QVector<QPointF> * ptr){ t_texture_coords_ = ptr; }
	void setPlane3DPtr(Plane3D * ptr){ t_plane_ = ptr; }
	QImage textureImage(){ return t_texture_image_; }
public slots:
    void run();

signals:
	// transmmit message to mainwindow
	void statusBar(QString info);
	void textEdit(QString info);
	void enableActionCameras();
	void textureImageDir(QString name);
	void enableTexture();
private:

	// all the dense points
	// note that the there are difference from  dense points and vertices: dense points are generated from
	// PMVS and vertices are generated from poisson surface reconstruction and are generated by interplation 
	QVector<Point> * t_dense_pts_;
	QSet<int> * t_points_ids_;	// points ids of the dense points
	QVector<Point> * t_vertices_; // all the vertices of the meshes
	QVector<QVector<int> > *t_facets_; // all the facets of the meshes
	QVector<QPair<int, int> > *t_edges_; // all the edges of the meshes
	//QMap<QString, QImage> * t_images_;// all images
	QMap<QString, cv::Mat> t_gray_images_;
	QMap<QString, QImage> t_texture_images_;// part of color images for creating texture image
	QVector<QPointF> *t_texture_coords_;	// texture coordinates of each vertex
	QMap<QString, Camera> *t_cameras_;	// all the cameras

	Plane3D *t_plane_;// a plane which covert a 3D problem to a 2.5D problem


	//--------------------------------------local variables---------------------------------------//
	// visiblility of all the dense points 
	QVector<QVector<int> > t_dense_vis_;
	// visibility of all vertices
	QVector<QVector<int> > t_vertices_vis_;
	// visibility of all the facets, each facet hase several possible vis
	QVector<QVector<int> > t_initial_facet_vis_;
	// textures of all the facets in all the corresponding views
	QVector<QVector<QVector<QPoint> > > t_initial_facet_coordinates_;
	// each facet is corresponding to only one vis in the final
	QVector<int> t_final_facets_vis_;
	// final texture coordidates corresponding to each facet
	QVector<QVector<QPoint> > t_final_facets_coordinates_;
	// width of texture image
	int t_width_;
	// height of texture image
	int t_height_;
	// project the vertices onto a plane
	QVector<QPointF> t_projected_coordinates_;

	QMap<uint, uint> t_label_mapping_;// key is the orinal labels and value is new labels
	float t_texture_XY_ratio_;// ratio of width and height of the texture image
	QVector<QVector<uint> > t_labels_;	// used for poisson image Editing// size is same to texutre image
	QImage t_texture_image_;

};
#endif